\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage{natbib}
\usepackage{url}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfig}
\graphicspath{{images/}}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\newcommand{\var}{\texttt}
\usepackage[toc,page]{appendix}

\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}

\title{Heuristics \& Approximations Algorithms}								% Title
\author{Alexander Falk}								% Author
\date{13 April 2020}											% Date

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}

\makeatletter
\let\OldStatex\Statex
\renewcommand{\Statex}[1][3]{%
  \setlength\@tempdima{\algorithmicindent}%
  \OldStatex\hskip\dimexpr#1\@tempdima\relax}
\makeatother

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
	\centering
    \vspace*{0.5 cm}
    \includegraphics[scale = 0.5]{SDU_logo.png}\\[1.0 cm]	% University Logo
    \textsc{\LARGE University of Southern Denmark}\\[2.0 cm]	% University Name
	\textsc{\Large DM852}\\[0.5 cm]				% Course Code
	\textsc{\Large \thedate}\\[0.5 cm]				% Date
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries \thetitle}\\
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
			\emph{Submitted To:}\\
			Marco Chiarandini\\
            Lene Monrad Favrholdt \\
			IMADA \\
			Institute of Mathematics \& Computer Science\\
			\end{flushleft}
			\end{minipage}~
			\begin{minipage}{0.4\textwidth}
            
			\begin{flushright} \large
			\emph{Submitted By:} \\
			Alexander Lerche Falk\\
            Fall - Master of Computer Science\\
		\end{flushright}
        
	\end{minipage}\\[2 cm]
	
	
    
    
    
    
	
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

The goal of this project is to show the knowledge acquired by the student in regards to Heuristic- and Local Search Algorithms. The algorithms are developed to suit the Capacitated Vehicle Routing Problem (CVRP). CVRP is a combinatorial optimization problemm, where a set of n customers has to be visited by m vehicles. Each customer can only be visited one vehicle. The sum of demands by the customers assigned to a vehicle must not overseed the capacity of the vehicle. All vehicles start and end their route at the depot (the starting point). The objective is to minimise the travelling cost and try to use as few vehicles as possible.  
Heuristics and Local Search algorithms are applied to CVRP, where the heuristics are laying the foundation of possible solutions of routes, and the Local Search algorithms try to improve the solutions.  
Three heuristic algorithms have been developed:  
\begin{itemize}
	\item Nearest Neightbour - Pick nearest customer from the depot or current customer without breaking the capacity
	\item Furthest Neightbour (with nearest clustering) - Pick customer furthest away from the depot, find the closest customers until the capacity is reached, and generate a route by using Nearest Neightbour
	\item K-Nearest Neightbour - Pick k nearest customers and randomly pick one of the k options. Proceed until no more customers without breaking the capacity
\end{itemize}  
Two local search algorithms have been developed:  

\begin{itemize}
	\item Two Opt - Pick a route generated by some heuristic. Pick two edges, swap the edges, and compare the distance from before and after the swap. If better, make the swap. 
	\item Three Opt - Pick a route generated by some heuristic. Pick three edges, swap the edges, and compare the distance from before and after the swap. If better, make the swap. 
\end{itemize}

At the end of the report, comparison of the heuristics and results are presented.

\newpage

\section{Nearest Neightbour} 

The Nearest Neightbour algorithm is a simple, yet powerful, approach to tackle CVRP. The algorithm goes starts at the depot and picks the nearest customer by iterating through all of the customers. It marks the customer and visited, adds it to a vehicle, and continues until the capacity of the vehicle is reached (or nearly reached). It returns to the depot and start over with the remaining customers. 

The algorithm is described in pseudocode:
\newline

\begin{algorithm}[!ht]
	\caption{Custom CVRP Heuristic - Nearest Neighbour Approach}\label{euclid}
	\begin{algorithmic}[1]
	\Require{$Point_{1} \dots Point_{N}$} 
	\Ensure{$Solution$ (solution to the CVRP instance)}
	\Function{algorithm}{{$Points[\;]$}}
	\State $\var{capacity} \gets \text{0}$
	\State $\var{data} \gets \text{CVRP instance}$
	\State $\var{visited} \gets \textit{empty array containing visited nodes}$
	\State $\var{shortestdistance} \gets \textit{0}$
	\State $\var{current} \gets \textit{keep track of next node to visit}$
	\For{\texttt{$\var{i} \gets 0$ to $\text{length of data-1}$}}
		\For{\texttt{$\var{j} \gets 1$ to $\text{length of data}$}}
			\State $temp \gets \var{euclideandistance(\var{current}, \var{j})}$
			\If{$j$ not in $visited$}
				\If{$temp \leq shortestdistance$}
					\State $shortestdistance \gets temp$
					\State $current \gets j$
					\State $visited \gets j$
					\newline\Comment{checking if capacity requirements are met}
					\If{$\text{current total capacity} \leq \text{max capacity}$}
						\State $capacity \gets \text{capacity of current node}$					
					\Else
						\State $\text{Add starting point to end of route and}$
						\State $\text{add capacity of current node to variable(\var{capacity})}$
					\EndIf
				\EndIf
			\EndIf
		\EndFor
		\State $shortestdistance \gets 0$ \Comment{reset shortestdistance}
	\EndFor

	\State \textbf{return} $solution$
	\EndFunction
	\end{algorithmic}
\end{algorithm}

\newpage
\section{First Custom Local Search Algorithms}
Having executed the heuristics, providing us with solutions to the initial problem instances, we can continue optimizing. This is where the Local Search Optimization algorithms comes into play. 
Given a canonical solution, we want to optimize it to reduce the total cost of the solution. We have provided three custom Local Search (LS) algorithms, trying to optimize the canonical solution.
All of our localsearches optimize solution by make exchanges of visiting node between 2 routes in solution set. Thus they can be used in combination with original Traveling salesman problem's localsearches such as 2-opt and 3-opt, where improvements are done by swapping and reversing order of visiting nodes in single route.
\newline
The first LS algorithm looks into the generated routes done by the heuristics. It takes two routes and compare them with each other, checking if any swaps are possible in the two routes. 
A swap is possible if the distance is being reduced in at least one route, while still preserving the maximum capacity limit of both routes. 
The second LS algorithm looks like the first but with a minor change. It takes one route and compares it with every other route to find a better solution. It then continues doing this 
with every other route. 


\section{Performance Analysis \& Boxplots}

\section{Process Analysis}

\newpage
\bibliographystyle{plain}
\bibliography{references}

\newpage
\begin{appendices}

\section{\\Custom Cluster Algorithm to solve CVRP}
% the \\ insures the section title is centered below the phrase: AppendixA

\begin{algorithm}[!ht]
	\caption{Cluster CVRP Localsearch}
	\begin{algorithmic}[1]
	\Require{$closest\_point(A, points)$: returns point in points which hase minimum distance from A} 
	\Require{$elim\_empty\_routes$: returns list of routes where the empty routes are removed}
	\Ensure{$routes$: Better Solution to the CVRP instance}
	\Function{algorithm}{{$routes$, $maxcap$}}
	\State $\var{route\_convexes}$ is an array storing convex\_hull for each route  
	\State $\var{improvements} \gets \text{True}$
	\While{\texttt{$\var{improvements}$}}
		\ForAll{$i$, $j$ such that $i$, $j$ are routes index combination}
			\State $\var{central\_point\_i} \gets$ average of point in convex i

			\State $\var{central\_point\_j} \gets$ average of point in convex j
			
			\State $\var{closest\_from\_i\_j} \gets \text{closest\_point(mid\_point\_i, convex\_routes[j])}$

			\State $\var{closest\_from\_j\_i} \gets \text{closest\_point(mid\_point\_j, convex\_routes[i])}$

			\If{$\var{closest\_from\_i\_j}$ and $\var{closest\_from\_j\_i}$ is Found}
			
			\If{$closest\_from\_i\_j$ fits in route j}
				\State \text{add move to route improvements j}
				\State \text{make the swap}
			\ElsIf{$closest\_from\_j\_i$ fits in route i}
				\State \text{add move to route improvements i}
				\State \text{make the swap}
			\ElsIf{capacity is not reached by swapping customers}
				\State \text{swap the route-points between i and j}
			\EndIf

			\If{$\var{improvements}$}
				\State recalculate convex hull of route i and j				
			\EndIf
			\EndIf
			\EndFor

		\If{\textbf{not} $\var{improvements}$}
			\State $\var{routes} = elim\_empty\_routes(\var{routes})$
			\Return $\var{routes}$
		\EndIf
	\EndWhile
	\EndFunction

	\end{algorithmic}
\end{algorithm}

\section{\\LocalSearch Algorithm - Swap if any improvement}

\begin{algorithm}[!ht]
	\caption{swap\_if\_improvement}
	\begin{algorithmic}[1]
		\Require{$dist(A,B)$ returns distance from point A to B}
	\Function{swap\_if\_improvement}{{$route\_i, route\_j, j\_to\_i, i\_to\_j$}}

	\State $\var{A}, \var{B}, \var{C} \gets \var{route\_i[i\_to\_j-1]}, \var{route\_i[i\_to\_j]},$
	\Statex $\var{route\_i[i\_to\_j+1 mod(\%) len(route\_i)]}$
	\State $\var{D}, \var{E}, \var{F} \gets \var{route\_j[j\_to\_i-1]}, \var{route\_j[j\_to\_i]},$ 
	\Statex $\var{route\_j[j\_to\_i+1 mod(\%) len(route\_j)]}$

	\State $\var{old\_distance\_i} \gets dist(\var{A},\var{B}) + dist(\var{B},\var{C})$
	\State $\var{old\_distance\_j} \gets dist(\var{D},\var{E}) + dist(\var{E},\var{F})$

	\State $\var{new\_distance\_i} \gets dist(\var{A},\var{E}) + dist(\var{E},\var{C})$
	\State $\var{new\_distance\_j} \gets dist(\var{D},\var{B}) + dist(\var{B},\var{F})$

	\If{$\var{old\_distance\_i} + \var{old\_distance\_j} >$ 
		\Statex $\var{new\_distance\_i} + \var{new\_distance\_j}$}
		\Statex $\text{swap point B of route i with point E of route j}$
		\Statex \Return True
	\EndIf
	\EndFunction

	\end{algorithmic}
\end{algorithm}

\newpage
\section{\\LocalSearch Algorithm - Move if any improvement}

\begin{algorithm}[!ht]
	\caption{move\_if\_improvement}
	\begin{algorithmic}[1]
		\Require{$dist(A,B)$ returns distance from point A to B}
	\Function{move\_if\_improvement}{{$route\_i, route\_j, i\_to\_j, j\_to\_i$}}

	\State $\var{A}, \var{B}, \var{C} \gets \var{route\_i[i\_to\_j -1]}, \var{route\_i[i\_to\_j]},$
	\Statex $\var{route\_i[i\_to\_j+1 \% len(route\_i)]}$

	\State $\var{D}, \var{E}, \var{F} \gets \var{route\_j[j\_to\_i -1]}, \var{route\_j[j\_to\_i]},$ 
	\Statex $\var{route\_j[j\_to\_i+1 \% len(route\_j)]}$


	\State $\var{old\_distance\_i} \gets dist(\var{A},\var{B}) + dist(\var{B},\var{C})$
	\State $\var{old\_distance\_j} \gets dist(\var{D},\var{E}) + dist(\var{E},\var{F})$

	\State $\var{new\_dist\_before\_B} \gets dist(\var{A},\var{E}) + dist(\var{E},\var{B}) + dist(\var{B},\var{C})$ 

	\State $\var{new\_dist\_after\_B} \gets dist(\var{A},\var{B}) + dist(\var{B},\var{E}) + dist(\var{E},\var{C})$ 

	\State $\var{new\_distance\_j} \gets dist(\var{D},\var{F})$

	\If{$\var{new\_dist\_before\_B} < {new\_dist\_after\_B}$}

		\If{$\var{old\_distance\_i} + \var{old\_distance\_j} >$ 
			\Statex $\var{new\_dist\_before\_B} + \var{new\_distance\_j}$}
			\Statex $\text{move point E from route j to route i before B}$
		\EndIf
	\Else

		\If{$\var{old\_distance\_i} + \var{old\_distance\_j} >$ 
			\Statex $\var{new\_dist\_after\_B} + \var{new\_distance\_j}$}
			\Statex $\text{move point E from route j to route i after B}$

		\EndIf
	\EndIf
	\EndFunction

	\end{algorithmic}
\end{algorithm}

\section{\\ BOXPLOT FIGURES}

\begin{figure}
	\centering
\end{figure}

\begin{figure}[!htb]
	\centering
\end{figure}

\begin{figure}[!htb]
	\centering
\end{figure}
\begin{figure}[!htb]
	\centering
\end{figure}

\begin{figure}[!htb]
	\centering
\end{figure}
\begin{figure}[!htb]
	\centering
\end{figure}

\begin{figure}[!htb]
	\centering
\end{figure}
\begin{figure}[!htb]
	\centering
\end{figure}

\end{appendices}
\end{document}